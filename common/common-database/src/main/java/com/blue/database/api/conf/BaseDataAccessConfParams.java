package com.blue.database.api.conf;

import org.apache.ibatis.session.AutoMappingBehavior;
import org.apache.ibatis.session.ExecutorType;

import java.util.List;
import java.util.Map;

/**
 * data access params
 *
 * @author liuyunfei
 * @date 2021/9/10
 * @apiNote
 */
@SuppressWarnings({"AlibabaAbstractMethodOrInterfaceMethodMustUseJavadoc", "unused", "SpellCheckingInspection"})
public abstract class BaseDataAccessConfParams implements DataAccessConf {

    /**
     * database shard
     */
    protected List<ShardingDatabaseAttr> shardingDatabases;

    /**
     * tables to be sharding
     */
    protected List<ShardingTableAttr> shardingTables;

    /**
     * table sharding size per db
     */
    protected Integer shardingTableSizePerDataBase;

    /**
     * data center id to db index mappings
     */
    protected List<IdentityToShardingMappingAttr> dataCenterToDatabaseMappings;

    /**
     * worker id to db index mappings
     */
    protected List<IdentityToShardingMappingAttr> workerToTableMappings;

    /**
     * broadcast tables, now supply for seata undolog
     */
    protected List<String> broadcastTables;

    /**
     * db and tables for not sharding
     */
    protected List<SingleDatabaseWithTablesAttr> singleDatabasesWithTables;

    /**
     * enable cache
     */
    protected Boolean cacheEnabled;

    /**
     * enable lazy loading
     */
    protected Boolean lazyLoadingEnabled;

    /**
     * enable aggress lazy loading
     */
    protected Boolean aggressiveLazyLoading;

    /**
     * enable multi result set
     */
    protected Boolean multipleResultSetsEnabled;

    /**
     * use column label
     */
    protected Boolean useColumnLabel;

    /**
     * use generated keys, false in summer, all id are generated by snowfalke
     */
    protected Boolean useGeneratedKeys;

    /**
     * connection timeout
     */
    protected Integer connectionTimeout;

    /**
     * auto mapping behavior
     */
    protected AutoMappingBehavior autoMappingBehavior;

    /**
     * executor type
     */
    protected ExecutorType executorType;

    /**
     * mybatis mapper location
     */
    protected String mapperLocation;

    /**
     * additional attributes
     */
    protected Map<String, String> props;

    public BaseDataAccessConfParams() {
    }

    @Override
    public List<ShardingDatabaseAttr> getShardingDatabases() {
        return shardingDatabases;
    }

    @Override
    public List<ShardingTableAttr> getShardingTables() {
        return shardingTables;
    }

    @Override
    public Integer getShardingTableSizePerDataBase() {
        return shardingTableSizePerDataBase;
    }

    @Override
    public List<IdentityToShardingMappingAttr> getDataCenterToDatabaseMappings() {
        return dataCenterToDatabaseMappings;
    }

    @Override
    public List<IdentityToShardingMappingAttr> getWorkerToTableMappings() {
        return workerToTableMappings;
    }

    @Override
    public List<String> getBroadcastTables() {
        return broadcastTables;
    }

    @Override
    public List<SingleDatabaseWithTablesAttr> getSingleDatabasesWithTables() {
        return singleDatabasesWithTables;
    }

    @Override
    public Boolean getCacheEnabled() {
        return cacheEnabled;
    }

    @Override
    public Boolean getLazyLoadingEnabled() {
        return lazyLoadingEnabled;
    }

    @Override
    public Boolean getAggressiveLazyLoading() {
        return aggressiveLazyLoading;
    }

    @Override
    public Boolean getMultipleResultSetsEnabled() {
        return multipleResultSetsEnabled;
    }

    @Override
    public Boolean getUseColumnLabel() {
        return useColumnLabel;
    }

    @Override
    public Boolean getUseGeneratedKeys() {
        return useGeneratedKeys;
    }

    @Override
    public Integer getConnectionTimeout() {
        return connectionTimeout;
    }

    @Override
    public AutoMappingBehavior getAutoMappingBehavior() {
        return autoMappingBehavior;
    }

    @Override
    public ExecutorType getExecutorType() {
        return executorType;
    }

    @Override
    public String getMapperLocation() {
        return mapperLocation;
    }

    @Override
    public Map<String, String> getProps() {
        return props;
    }

    public void setShardingDatabases(List<ShardingDatabaseAttr> shardingDatabases) {
        this.shardingDatabases = shardingDatabases;
    }

    public void setShardingTables(List<ShardingTableAttr> shardingTables) {
        this.shardingTables = shardingTables;
    }

    public void setShardingTableSizePerDataBase(Integer shardingTableSizePerDataBase) {
        this.shardingTableSizePerDataBase = shardingTableSizePerDataBase;
    }

    public void setDataCenterToDatabaseMappings(List<IdentityToShardingMappingAttr> dataCenterToDatabaseMappings) {
        this.dataCenterToDatabaseMappings = dataCenterToDatabaseMappings;
    }

    public void setWorkerToTableMappings(List<IdentityToShardingMappingAttr> workerToTableMappings) {
        this.workerToTableMappings = workerToTableMappings;
    }

    public void setBroadcastTables(List<String> broadcastTables) {
        this.broadcastTables = broadcastTables;
    }

    public void setSingleDatabasesWithTables(List<SingleDatabaseWithTablesAttr> singleDatabasesWithTables) {
        this.singleDatabasesWithTables = singleDatabasesWithTables;
    }

    public void setCacheEnabled(Boolean cacheEnabled) {
        this.cacheEnabled = cacheEnabled;
    }

    public void setLazyLoadingEnabled(Boolean lazyLoadingEnabled) {
        this.lazyLoadingEnabled = lazyLoadingEnabled;
    }

    public void setAggressiveLazyLoading(Boolean aggressiveLazyLoading) {
        this.aggressiveLazyLoading = aggressiveLazyLoading;
    }

    public void setMultipleResultSetsEnabled(Boolean multipleResultSetsEnabled) {
        this.multipleResultSetsEnabled = multipleResultSetsEnabled;
    }

    public void setUseColumnLabel(Boolean useColumnLabel) {
        this.useColumnLabel = useColumnLabel;
    }

    public void setUseGeneratedKeys(Boolean useGeneratedKeys) {
        this.useGeneratedKeys = useGeneratedKeys;
    }

    public void setConnectionTimeout(Integer connectionTimeout) {
        this.connectionTimeout = connectionTimeout;
    }

    public void setAutoMappingBehavior(AutoMappingBehavior autoMappingBehavior) {
        this.autoMappingBehavior = autoMappingBehavior;
    }

    public void setExecutorType(ExecutorType executorType) {
        this.executorType = executorType;
    }

    public void setMapperLocation(String mapperLocation) {
        this.mapperLocation = mapperLocation;
    }

    public void setProps(Map<String, String> props) {
        this.props = props;
    }

    @Override
    public String toString() {
        return "BaseDataAccessConfParams{" +
                "shardingDatabases=" + shardingDatabases +
                ", shardingTables=" + shardingTables +
                ", shardingTableSizePerDataBase=" + shardingTableSizePerDataBase +
                ", dataCenterToDatabaseMappings=" + dataCenterToDatabaseMappings +
                ", workerToTableMappings=" + workerToTableMappings +
                ", broadcastTables=" + broadcastTables +
                ", singleDatabasesWithTables=" + singleDatabasesWithTables +
                ", cacheEnabled=" + cacheEnabled +
                ", lazyLoadingEnabled=" + lazyLoadingEnabled +
                ", aggressiveLazyLoading=" + aggressiveLazyLoading +
                ", multipleResultSetsEnabled=" + multipleResultSetsEnabled +
                ", useColumnLabel=" + useColumnLabel +
                ", useGeneratedKeys=" + useGeneratedKeys +
                ", connectionTimeout=" + connectionTimeout +
                ", autoMappingBehavior=" + autoMappingBehavior +
                ", executorType=" + executorType +
                ", mapperLocation='" + mapperLocation + '\'' +
                ", props=" + props +
                '}';
    }

}
